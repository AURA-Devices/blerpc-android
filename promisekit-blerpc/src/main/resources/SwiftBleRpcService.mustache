import Foundation
import RxBluetoothKit
import CoreBluetooth
import RxSwift
import PromiseKit

/// Extension to support {{serviceName}} service
public extension BleWorker {

    /// UUID of service
    static let {{serviceName}}UUID: String = "{{serviceUUID}}"

{{#methods}}
    {{#typeRead}}
    /// Send read request of method {{methodName}} on device
    /// - parameter request: {{inputType}}
    /// - returns: {{outputType}} if success
    /// - warning: rejects when there is error in sending data
    public func {{methodName}}(request: {{inputType}}) -> Promise<{{outputType}}> {
        return Promise { seal in
            _ = self.discoverCharacteristic(serviceUUID: "{{serviceUUID}}", characteristicUUID: "{{characteristicUUID}}").map { characteristic in
                _ = characteristic.readValue().subscribe(onSuccess: { (characteristic) in
                    guard let data = characteristic.value else {
                        seal.reject(wrongDataError)
                        return
                    }
                    let proto = {{outputType}}.decode(data: data)
                    seal.fulfill(proto)
                }, onError: { (error) in
                    seal.reject(error)
                })
            }
        }
    }
    {{/typeRead}}

    {{#typeWrite}}
    /// Send write request of method {{methodName}} on device
    /// - parameter request: {{inputType}}
    /// - returns: *Void* if success
    /// - warning: rejects when there is error in sending data
    public func {{methodName}}(request: {{inputType}}) -> Promise<Void> {
        return Promise { seal in
            let data = {{inputType}}.encode(proto: request)
            _ = self.discoverCharacteristic(serviceUUID: "{{serviceUUID}}", characteristicUUID: "{{characteristicUUID}}").map { characteristic in
                _ = characteristic.writeValue(data, type: .withResponse).subscribe { event in
                    switch event {
                    case .success:
                        seal.fulfill(())
                    case .error(let error):
                        seal.reject(error)
                    }
                }
            }
        }
    }
    {{/typeWrite}}

    {{#typeSubscribe}}
    /// Send subscribe request of method {{methodName}} on device
    /// - parameter complition: closure which calls when new data appears
    /// - parameter error: closure which calls when error occurs
    public func {{methodName}}(complition: @escaping ({{outputType}}) -> Void, error: @escaping (Error) -> Void) {
        _ = self.discoverCharacteristic(serviceUUID: "{{serviceUUID}}", characteristicUUID: "{{characteristicUUID}}").map { characteristic in
            let disposable = characteristic.observeValueUpdateAndSetNotification().subscribe({ (event) in
                switch event {
                    case .completed:
                    break
                case .error(let err):
                    error(err)
                case .next(let characteristic):
                    guard let data = characteristic.value else {
                        error(wrongDataError)
                        return
                    }
                    let proto = {{outputType}}.decode(data: data)
                    complition(proto)
                }
            })

            self.disposableBag["\("{{serviceUUID}}") - \("{{characteristicUUID}}")"] = disposable
        }
    }

    /// Unsubscribe from receiving {{methodName}} updates
    public func unsubscribe{{upperCasedMethodName}}() {
        self.disconnectFrom(serviceUUID: "{{serviceUUID}}", characteristicUUID: "{{characteristicUUID}}")
    }
    {{/typeSubscribe}}

{{/methods}}
}
