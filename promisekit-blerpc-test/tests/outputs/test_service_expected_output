import Foundation
import RxBluetoothKit
import CoreBluetooth
import RxSwift
import PromiseKit

/// TestService service
public class TestService: BleAbstractService {

    /// UUID of service
    public static let TestServiceUUID: String = "A0000000-0000-0000-0000-000000000000"

    private let accessQueue = DispatchQueue(label: "TestServiceQueue", attributes: .concurrent)

    /// Send read request of method readValue on device
    /// - parameter request: My_Device_GetValueRequest
    /// - returns: My_Device_GetValueResponse if success
    /// - warning: rejects when there is error in sending data
    public func readValue(request: My_Device_GetValueRequest) -> Promise<My_Device_GetValueResponse> {
        return Promise { seal in
            _ = self.bleWorker.discoverCharacteristic(serviceUUID: "A0000000-0000-0000-0000-000000000000", characteristicUUID: "A0000001-0000-0000-0000-000000000000").map { characteristic in
                _ = characteristic.readValue().subscribe(onSuccess: { (characteristic) in
                    guard let data = characteristic.value else {
                        let wrongDataError = NSError(domain: "ble-module.errors", code: 0, userInfo:
                                            [NSLocalizedDescriptionKey: "Device returned empty response"])
                        seal.reject(wrongDataError)
                        return
                    }

                    do {
                        let proto = try My_Device_GetValueResponse.decode(data: data)
                        seal.fulfill(proto)
                    } catch {
                        seal.reject(error)
                    }
                }, onError: { (error) in
                    seal.reject(error)
                })
            }
        }
    }




    /// Send write request of method writeValue on device
    /// - parameter request: My_Device_SetValueRequest
    /// - returns: My_Device_SetValueResponse if success
    /// - warning: rejects when there is error in sending data
    public func writeValue(request: My_Device_SetValueRequest) -> Promise<My_Device_SetValueResponse> {
        return Promise { seal in
            do {
                let data = try My_Device_SetValueRequest.encode(proto: request)
                _ = self.bleWorker.discoverCharacteristic(serviceUUID: "A0000000-0000-0000-0000-000000000000", characteristicUUID: "A0000001-0000-0000-0000-000000000000").map { characteristic in
                    _ = characteristic.writeValue(data, type: .withResponse).subscribe { event in
                        switch event {
                        case .success:
                            guard let data = characteristic.value else {
                                let wrongDataError = NSError(domain: "ble-module.errors", code: 0, userInfo:
                                                    [NSLocalizedDescriptionKey: "Device returned empty response"])
                                seal.reject(wrongDataError)
                                return
                            }

                            do {
                                let proto = try My_Device_SetValueResponse.decode(data: data)
                                seal.fulfill(proto)
                            } catch {
                                seal.reject(error)
                            }
                        case .error(let error):
                            seal.reject(error)
                        }
                    }
                }
            } catch {
                seal.reject(error)
            }
        }
    }




    private var getValueUpdatesCallbacks: [BleOperationHandler<My_Device_GetValueResponse,Void>] = []

    /// Send subscribe request of method getValueUpdates on device. Method can be used to multi subscribe feature
    /// - parameter request: My_Device_GetValueRequest
    /// - parameter completion: closure which calls when new data appears
    /// - parameter error: closure which calls when error occurs
    /// - returns: handler with with we can identify subscriber
    public func getValueUpdates(request: My_Device_GetValueRequest, completion: @escaping (My_Device_GetValueResponse) -> Void,
                                 error: @escaping (Error) -> Void) -> BleOperationHandler<My_Device_GetValueResponse,Void> {
        let handler = BleOperationHandler.init(id: getValueUpdatesCallbacks.count + 1, completionClosure: completion,
                 errorClosure: error, service: self, unsubscribeSelector: Selector(("unsubscribeGetValueUpdates:")))

        self.accessQueue.async(flags: .barrier) {
            self.getValueUpdatesCallbacks.append(handler)
            
            if self.getValueUpdatesCallbacks.count <= 1 {
                self.accessQueue.async {
                    _ = self.bleWorker.discoverCharacteristic(serviceUUID: "A0000000-0000-0000-0000-000000000000", characteristicUUID: "A0000001-0000-0000-0000-000000000000").map { [weak self] characteristic in
                        let disposable = characteristic.observeValueUpdateAndSetNotification().subscribe({ (event) in
                            switch event {
                            case .completed:
                                break
                            case .error(let err):
                                guard let selfG = self else { return }
                                for errorCallback in selfG.getValueUpdatesCallbacks {
                                    errorCallback.errorClosure(err)
                                }
                            case .next(let characteristic):
                                guard let data = characteristic.value else {
                                    guard let selfG = self else { return }

                                    let wrongDataError = NSError(domain: "ble-module.errors", code: 0, userInfo:
                                                        [NSLocalizedDescriptionKey: "Device returned empty response"])
                                    for errorCallback in selfG.getValueUpdatesCallbacks {
                                        errorCallback.errorClosure(wrongDataError)
                                    }
                                    return
                                }
                                guard let selfG = self else { return }

                                do {
                                    let proto = try My_Device_GetValueResponse.decode(data: data)

                                    for completionCallback in selfG.getValueUpdatesCallbacks {
                                        completionCallback.completionClosure(proto)
                                    }
                                } catch {
                                    for errorCallback in selfG.getValueUpdatesCallbacks {
                                        errorCallback.errorClosure(error)
                                    }
                                }
                            }
                        })
                        
                        let disposableId = BleOperationIdentifier.init(serviceUUID: UUID.init(uuidString: "A0000000-0000-0000-0000-000000000000")!,
                                            			        characteristicUUID: UUID.init(uuidString: "A0000001-0000-0000-0000-000000000000")!)
                        self?.bleWorker.disposableBag[disposableId] = disposable
                    }
                }
            }
        }

        return handler
    }

    /// Unsubscribe from receiving getValueUpdates updates
    /// - parameter obj: handler which needs to be unsubscribed
    @objc private func unsubscribeGetValueUpdates(_ obj: Any) {
        let handler = obj as! BleOperationHandler<My_Device_GetValueResponse,Void>
        var foundedHandlerIndex: Int?

        accessQueue.sync {
            for index in 0..<getValueUpdatesCallbacks.count {
                let tempHandler = self.getValueUpdatesCallbacks[index]

                if tempHandler.id == handler.id {
                		foundedHandlerIndex = index
                }
            }
        }

        accessQueue.async(flags: .barrier) {
            if let index = foundedHandlerIndex {
                self.getValueUpdatesCallbacks.remove(at: index)
            }
    	}

        accessQueue.sync {
            if self.getValueUpdatesCallbacks.count <= 0 {
                let disposableId = BleOperationIdentifier.init(serviceUUID: UUID.init(uuidString: "A0000000-0000-0000-0000-000000000000")!,
                                                characteristicUUID: UUID.init(uuidString: "A0000001-0000-0000-0000-000000000000")!)
                self.bleWorker.disconnectFrom(disposableId)
            }
        }
    }

}
